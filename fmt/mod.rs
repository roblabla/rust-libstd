// Copyright 2013 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use prelude::*;

use cast;
use char::Char;
use rt::io::Decorator;
use rt::io::mem::MemWriter;
use rt::io;
use str;
use sys;
use util;
use vec;

pub mod parse;
pub mod rt;

/// A struct to represent both where to emit formatting strings to and how they
/// should be formatted. A mutable version of this is passed to all formatting
/// traits.
pub struct Formatter<'self> {
    /// Flags for formatting (packed version of rt::Flag)
    flags: uint,
    /// Character used as 'fill' whenever there is alignment
    fill: char,
    /// Boolean indication of whether the output should be left-aligned
    align: parse::Alignment,
    /// Optionally specified integer width that the output should be
    width: Option<uint>,
    /// Optionally specified precision for numeric types
    precision: Option<uint>,

    /// Output buffer.
    buf: &'self mut io::Writer,

    priv curarg: vec::VecIterator<'self, Argument<'self>>,
    priv args: &'self [Argument<'self>],
}

/// This struct represents the generic "argument" which is taken by the Xprintf
/// family of functions. It contains a function to format the given value. At
/// compile time it is ensured that the function and the value have the correct
/// types, and then this struct is used to canonicalize arguments to one type.
pub struct Argument<'self> {
    priv formatter: extern "Rust" fn(&util::Void, &mut Formatter),
    priv value: &'self util::Void,
}

#[allow(missing_doc)]
pub trait Bool { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait Char { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait Signed { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait Unsigned { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait Octal { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait Binary { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait LowerHex { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait UpperHex { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait String { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait Poly { fn fmt(&Self, &mut Formatter); }
#[allow(missing_doc)]
pub trait Pointer { fn fmt(&Self, &mut Formatter); }

/// The sprintf function takes a precompiled format string and a list of
/// arguments, to return the resulting formatted string.
///
/// This is currently an unsafe function because the types of all arguments
/// aren't verified by immediate callers of this function. This currently does
/// not validate that the correct types of arguments are specified for each
/// format specifier, nor that each argument itself contains the right function
/// for formatting the right type value. Because of this, the function is marked
/// as `unsafe` if this is being called manually.
///
/// Thankfully the rust compiler provides the macro `ifmt!` which will perform
/// all of this validation at compile-time and provides a safe interface for
/// invoking this function.
///
/// # Arguments
///
///   * fmts - the precompiled format string to emit.
///   * args - the list of arguments to the format string. These are only the
///            positional arguments (not named)
///
/// Note that this function assumes that there are enough arguments for the
/// format string.
pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {
    let output = MemWriter::new();
    {
        let mut formatter = Formatter {
            flags: 0,
            width: None,
            precision: None,
            // FIXME(#8248): shouldn't need a transmute
            buf: cast::transmute(&output as &io::Writer),
            align: parse::AlignUnknown,
            fill: ' ',
            args: args,
            curarg: args.iter(),
        };
        for piece in fmt.iter() {
            formatter.run(piece, None);
        }
    }
    return str::from_bytes_owned(output.inner());
}

impl<'self> Formatter<'self> {

    // First up is the collection of functions used to execute a format string
    // at runtime. This consumes all of the compile-time statics generated by
    // the ifmt! syntax extension.

    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {
        let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {
            match *cnt {
                parse::CountIs(n) => { *slot = Some(n); }
                parse::CountImplied => { *slot = None; }
                parse::CountIsParam(i) => {
                    let v = self.args[i].value;
                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }
                }
                parse::CountIsNextParam => {
                    let v = self.curarg.next().unwrap().value;
                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }
                }
            }
        };

        match *piece {
            rt::String(s) => { self.buf.write(s.as_bytes()); }
            rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }
            rt::Argument(ref arg) => {
                // Fill in the format parameters into the formatter
                self.fill = arg.format.fill;
                self.align = arg.format.align;
                self.flags = arg.format.flags;
                setcount(&mut self.width, &arg.format.width);
                setcount(&mut self.precision, &arg.format.precision);

                // Extract the correct argument
                let value = match arg.position {
                    rt::ArgumentNext => { *self.curarg.next().unwrap() }
                    rt::ArgumentIs(i) => self.args[i],
                };

                // Then actually do some printing
                match arg.method {
                    None => { (value.formatter)(value.value, self); }
                    Some(ref method) => { self.execute(*method, value); }
                }
            }
        }
    }

    fn execute(&mut self, method: &rt::Method, arg: Argument) {
        match *method {
            // Pluralization is selection upon a numeric value specified as the
            // parameter.
            rt::Plural(offset, ref selectors, ref default) => {
                // This is validated at compile-time to be a pointer to a
                // '&uint' value.
                let value: &uint = unsafe { cast::transmute(arg.value) };
                let value = *value;

                // First, attempt to match against explicit values without the
                // offsetted value
                for s in selectors.iter() {
                    match s.selector {
                        Right(val) if value == val => {
                            return self.runplural(value, s.result);
                        }
                        _ => {}
                    }
                }

                // Next, offset the value and attempt to match against the
                // keyword selectors.
                let value = value - match offset { Some(i) => i, None => 0 };
                for s in selectors.iter() {
                    let run = match s.selector {
                        Left(parse::Zero) => value == 0,
                        Left(parse::One) => value == 1,
                        Left(parse::Two) => value == 2,

                        // XXX: Few/Many should have a user-specified boundary
                        //      One possible option would be in the function
                        //      pointer of the 'arg: Argument' struct.
                        Left(parse::Few) => value < 8,
                        Left(parse::Many) => value >= 8,

                        Right(*) => false
                    };
                    if run {
                        return self.runplural(value, s.result);
                    }
                }

                self.runplural(value, *default);
            }

            // Select is just a matching against the string specified.
            rt::Select(ref selectors, ref default) => {
                // This is validated at compile-time to be a pointer to a
                // string slice,
                let value: & &str = unsafe { cast::transmute(arg.value) };
                let value = *value;

                for s in selectors.iter() {
                    if s.selector == value {
                        for piece in s.result.iter() {
                            self.run(piece, Some(value));
                        }
                        return;
                    }
                }
                for piece in default.iter() {
                    self.run(piece, Some(value));
                }
            }
        }
    }

    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {
        do ::uint::to_str_bytes(value, 10) |buf| {
            let valuestr = str::from_bytes_slice(buf);
            for piece in pieces.iter() {
                self.run(piece, Some(valuestr));
            }
        }
    }

    // Helper methods used for padding and processing formatting arguments that
    // all formatting traits can use.

    /// TODO: dox
    pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,
                        positive: bool) {
        use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};

        let mut actual_len = s.len();
        if self.flags & 1 << (FlagAlternate as uint) != 0 {
            actual_len += alternate_prefix.len();
        }
        if self.flags & 1 << (FlagSignPlus as uint) != 0 {
            actual_len += 1;
        } else if !positive {
            actual_len += 1;
        }

        let mut signprinted = false;
        let sign = |this: &mut Formatter| {
            if !signprinted {
                if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {
                    this.buf.write(['+' as u8]);
                } else if !positive {
                    this.buf.write(['-' as u8]);
                }
                if this.flags & 1 << (FlagAlternate as uint) != 0 {
                    this.buf.write(alternate_prefix.as_bytes());
                }
                signprinted = true;
            }
        };

        let emit = |this: &mut Formatter| {
            sign(this);
            this.buf.write(s);
        };

        match self.width {
            None => { emit(self) }
            Some(min) if actual_len >= min => { emit(self) }
            Some(min) => {
                if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {
                    self.fill = '0';
                    sign(self);
                }
                do self.with_padding(min - actual_len, parse::AlignRight) |me| {
                    emit(me);
                }
            }
        }
    }

    /// This function takes a string slice and emits it to the internal buffer
    /// after applying the relevant formatting flags specified. The flags
    /// recognized for generic strings are:
    ///
    /// * width - the minimum width of what to emit
    /// * fill/align - what to emit and where to emit it if the string
    ///                provided needs to be padded
    /// * precision - the maximum length to emit, the string is truncated if it
    ///               is longer than this length
    ///
    /// Notably this function ignored the `flag` parameters
    pub fn pad(&mut self, s: &str) {
        // Make sure there's a fast path up front
        if self.width.is_none() && self.precision.is_none() {
            self.buf.write(s.as_bytes());
            return
        }
        // The `precision` field can be interpreted as a `max-width` for the
        // string being formatted
        match self.precision {
            Some(max) => {
                // If there's a maximum width and our string is longer than
                // that, then we must always have truncation. This is the only
                // case where the maximum length will matter.
                let char_len = s.char_len();
                if char_len >= max {
                    let nchars = ::uint::min(max, char_len);
                    self.buf.write(s.slice_chars(0, nchars).as_bytes());
                    return
                }
            }
            None => {}
        }

        // The `width` field is more of a `min-width` parameter at this point.
        match self.width {
            // If we're under the maximum length, and there's no minimum length
            // requirements, then we can just emit the string
            None => { self.buf.write(s.as_bytes()) }

            // If we're under the maximum width, check if we're over the minimum
            // width, if so it's as easy as just emitting the string.
            Some(width) if s.char_len() >= width => {
                self.buf.write(s.as_bytes())
            }

            // If we're under both the maximum and the minimum width, then fill
            // up the minimum width with the specified string + some alignment.
            Some(width) => {
                do self.with_padding(width - s.len(), parse::AlignLeft) |me| {
                    me.buf.write(s.as_bytes());
                }
            }
        }
    }

    fn with_padding(&mut self, padding: uint,
                    default: parse::Alignment, f: &fn(&mut Formatter)) {
        let align = match self.align {
            parse::AlignUnknown => default,
            parse::AlignLeft | parse::AlignRight => self.align
        };
        if align == parse::AlignLeft {
            f(self);
        }
        let mut fill = [0u8, ..4];
        let len = self.fill.encode_utf8(fill);
        for _ in range(0, padding) {
            self.buf.write(fill.slice_to(len));
        }
        if align == parse::AlignRight {
            f(self);
        }
    }
}

/// This is a function which calls are emitted to by the compiler itself to
/// create the Argument structures that are passed into the `sprintf` function.
#[doc(hidden)]
pub fn argument<'a, T>(f: extern "Rust" fn(&T, &mut Formatter),
                       t: &'a T) -> Argument<'a> {
    unsafe {
        Argument {
            formatter: cast::transmute(f),
            value: cast::transmute(t)
        }
    }
}

/// When the compiler determines that the type of an argument *must* be a string
/// (such as for select), then it invokes this method.
#[doc(hidden)]
pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {
    argument(String::fmt, s)
}

/// When the compiler determines that the type of an argument *must* be a uint
/// (such as for plural), then it invokes this method.
#[doc(hidden)]
pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {
    argument(Unsigned::fmt, s)
}

// Implementations of the core formatting traits

impl Bool for bool {
    fn fmt(b: &bool, f: &mut Formatter) {
        String::fmt(&(if *b {"true"} else {"false"}), f);
    }
}

impl<'self> String for &'self str {
    fn fmt(s: & &'self str, f: &mut Formatter) {
        f.pad(*s);
    }
}

impl Char for char {
    fn fmt(c: &char, f: &mut Formatter) {
        let mut utf8 = [0u8, ..4];
        let amt = c.encode_utf8(utf8);
        let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };
        String::fmt(&s, f);
    }
}

macro_rules! int_base(($ty:ident, $into:ident, $base:expr,
                       $name:ident, $prefix:expr) => {
    impl $name for $ty {
        fn fmt(c: &$ty, f: &mut Formatter) {
            do ::$into::to_str_bytes(*c as $into, $base) |buf| {
                f.pad_integral(buf, $prefix, true);
            }
        }
    }
})
macro_rules! upper_hex(($ty:ident, $into:ident) => {
    impl UpperHex for $ty {
        fn fmt(c: &$ty, f: &mut Formatter) {
            do ::$into::to_str_bytes(*c as $into, 16) |buf| {
                upperhex(buf, f);
            }
        }
    }
})
// Not sure why, but this causes an "unresolved enum variant, struct or const"
// when inlined into the above macro...
#[doc(hidden)]
pub fn upperhex(buf: &[u8], f: &mut Formatter) {
    let mut local = [0u8, ..16];
    for i in ::iterator::range(0, buf.len()) {
        local[i] = match buf[i] as char {
            'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,
            c => c as u8,
        }
    }
    f.pad_integral(local.slice_to(buf.len()), "0x", true);
}

// FIXME(#4375) shouldn't need an inner module
macro_rules! integer(($signed:ident, $unsigned:ident) => {
    mod $signed {
        use super::*;

        // Signed is special because it actuall emits the negative sign,
        // nothing else should do that, however.
        impl Signed for $signed {
            fn fmt(c: &$signed, f: &mut Formatter) {
                do ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10) |buf| {
                    f.pad_integral(buf, "", *c >= 0);
                }
            }
        }
        int_base!($signed, $unsigned, 2, Binary, "0b")
        int_base!($signed, $unsigned, 8, Octal, "0o")
        int_base!($signed, $unsigned, 16, LowerHex, "0x")
        upper_hex!($signed, $unsigned)

        int_base!($unsigned, $unsigned, 2, Binary, "0b")
        int_base!($unsigned, $unsigned, 8, Octal, "0o")
        int_base!($unsigned, $unsigned, 10, Unsigned, "")
        int_base!($unsigned, $unsigned, 16, LowerHex, "0x")
        upper_hex!($unsigned, $unsigned)
    }
})

integer!(int, uint)
integer!(i8, u8)
integer!(i16, u16)
integer!(i32, u32)
integer!(i64, u64)

impl<T> Poly for T {
    fn fmt(t: &T, f: &mut Formatter) {
        match (f.width, f.precision) {
            (None, None) => {
                // XXX: sys::log_str should have a variant which takes a stream
                //      and we should directly call that (avoids unnecessary
                //      allocations)
                let s = sys::log_str(t);
                f.buf.write(s.as_bytes());
            }

            // If we have a specified width for formatting, then we have to make
            // this allocation of a new string
            _ => {
                let s = sys::log_str(t);
                f.pad(s);
            }
        }
    }
}

// n.b. use 'const' to get an implementation for both '*mut' and '*' at the same
//      time.
impl<T> Pointer for *const T {
    fn fmt(t: &*const T, f: &mut Formatter) {
        f.flags |= 1 << (parse::FlagAlternate as uint);
        do ::uint::to_str_bytes(*t as uint, 16) |buf| {
            f.pad_integral(buf, "0x", true);
        }
    }
}

// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,
// it's a lot easier than creating all of the rt::Piece structures here.
